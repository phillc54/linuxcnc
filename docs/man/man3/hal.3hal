'\" t
.\"     Title: intro
.\"    Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 05/27/2025
.\"    Manual: LinuxCNC Documentation
.\"    Source: LinuxCNC
.\"  Language: English
.\"
.TH "INTRO" "3hal" "05/27/2025" "LinuxCNC" "LinuxCNC Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
hal \- Introduction to the HAL API
.SH "DESCRIPTION"
.sp
HAL stands for Hardware Abstraction Layer, and is used by LinuxCNC to transfer realtime data to and from I/O devices and other low\-level modules\&.
.sp
\fBhal\&.h\fR defines the API and data structures used by the HAL\&. This file is included in both realtime and non\-realtime HAL components\&. HAL uses the RTPAI real\-time interface, and the #define symbols RTAPI and ULAPI are used to distinguish between realtime and non\-realtime code\&. The API defined in this file is implemented in hal_lib\&.c and can be compiled for linking to either realtime or non\-realtime HAL components\&.
.sp
The HAL is a very modular approach to the low level parts of a motion control system\&. The goal of the HAL is to allow a systems integrator to connect a group of software components together to meet whatever I/O requirements he (or she) needs\&. This includes realtime and non\-realtime I/O, as well as basic motor control up to and including a PID position loop\&. What these functions have in common is that they all process signals\&. In general, a signal is a data item that is updated at regular intervals\&. For example, a PID loop gets position command and feedback signals, and produces a velocity command signal\&.
.sp
HAL is based on the approach used to design electronic circuits\&. In electronics, off\-the\-shelf components like integrated circuits are placed on a circuit board and their pins are interconnected to build whatever overall function is needed\&. The individual components may be as simple as an op\-amp, or as complex as a digital signal processor\&. Each component can be individually tested, to make sure it works as designed\&. After the components are placed in a larger circuit, the signals connecting them can still be monitored for testing and troubleshooting\&.
.sp
Like electronic components, HAL components have pins, and the pins can be interconnected by signals\&.
.sp
In the HAL, a \fIsignal\fR contains the actual data value that passes from one pin to another\&. When a signal is created, space is allocated for the data value\&. A \fIpin\fR on the other hand, is a pointer, not a data value\&. When a pin is connected to a signal, the pin\(cqs pointer is set to point at the signal\(cqs data value\&. This allows the component to access the signal with very little run\-time overhead\&. (If a pin is not linked to any signal, the pointer points to a dummy location, so the realtime code doesn\(cqt have to deal with null pointers or treat unlinked variables as a special case in any way\&.)
.sp
There are three approaches to writing a HAL component\&. Those that do not require hard realtime performance can be written as a regular non\-realtime process\&. Components that need hard realtime performance but have simple configuration and init requirements can be done as a single realtime component, using either pre\-defined init info, or load\-time parameters\&. Finally, complex components may use both a realtime component for the realtime part, and a non\-realtime process to handle INI file access, user interface (possibly including GUI features), and other details\&.
.sp
HAL uses the RTAPI/ULAPI interface\&. If RTAPI is #defined, hal_lib\&.c generates a realtime\-capable library (to be insmoded into the kernel or linked to a realtime process) that provides the functions for all realtime components\&. The same source file compiled with the ULAPI #define would make a non\-realtime library that would be linked to non\-realtime code to make non\-realtime executables\&. The variable lists and link information are stored in a block of shared memory and protected with mutexes, so that realtime components and non\-realtime programs can access the data\&.
.SH "REALTIME CONSIDERATIONS"
.sp
For an explanation of realtime considerations, see \fBintro(3rtapi)\fR\&.
.SH "HAL STATUS CODES"
.sp
Except as noted in specific manual pages, HAL returns negative errno values for errors, and non\-negative values for success\&.
.SH "SEE ALSO"
.sp
rtapi(3)
