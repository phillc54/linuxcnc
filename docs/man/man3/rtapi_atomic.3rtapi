'\" t
.\"     Title: rtapi_atomic
.\"    Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 05/27/2025
.\"    Manual: LinuxCNC Documentation
.\"    Source: LinuxCNC
.\"  Language: English
.\"
.TH "RTAPI_ATOMIC" "3rtapi" "05/27/2025" "LinuxCNC" "LinuxCNC Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
rtapi_atomic \- subset of C11 stdatomic\&.h
.SH "SYNTAX"
.sp
.if n \{\
.RS 4
.\}
.nf
#include <rtapi_atomic\&.h>
enum memory_order { \&.\&.\&. };
#define atomic_store(obj, desired)\&.\&.\&.
#define atomic_store_explicit(obj, desired, order)\&.\&.\&.
#define atomic_load(obj)\&.\&.\&.
#define atomic_load_explicit(obj, order)\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.SH "ARGUMENTS"
.PP
volatile A* obj
.RS 4
A pointer to a volatile object that is the destination of the store or the source of the load\&. The pointer must have an appropriate type and alignment such that the underlying store or load operation itself is atomic; at a minimum, a properly aligned "int" may be assumed to be such a type\&. Improper size or alignment are undiagnosed errors\&.
.RE
.PP
C desired
.RS 4
The value to be stored in the object\&. "*obj = desired" must be well\-formed\&.
.RE
.PP
memory_order order
.RS 4
The required memory ordering semantic\&.
.RE
.SH "DESCRIPTION"
.sp
This header provides at least the subset of C11\(cqs <+stdatomic\&.h>+ given above\&. When there is an ordering requirement for multiple values read or written in RTAPI shared memory areas by other threads of execution, including the values of HAL pins and parameters, these functions (or function\-like macros) are the only way to ensure the ordering requirement is obeyed\&. Otherwise, according to architecture\-specific rules, loads and stores may be reordered from their normal source code order\&.
.sp
For example, to leave a message in a shared memory area from one thread and retrieve it from another, the writer must use an atomic store for the "message is complete" variable, and the reader must use an atomic load when checking that variable:
.sp
.if n \{\
.RS 4
.\}
.nf
// producer
*message = 42;
atomic_store_explicit(message_ready, 1, memory_order_release);

// consumer
while(atomic_load_explicit(message_ready, memory_order_acquire) == 0) sched_yield();
printf("message was %d\en", *message); // must print 42
.fi
.if n \{\
.RE
.\}
.SH "REALTIME CONSIDERATIONS"
.sp
May be called from any code\&.
.SH "RETURN VALUE"
.sp
\fBatomic_load\fR and \fBatomic_load_explicit\fR return the value pointed to by the \fIobj\fR argument\&.
.sp
\fBatomic_store\fR and \fBatomic_store_explicit\fR have no return value\&.
.SH "SEE ALSO"
.sp
<stdatomic\&.h> (C11), <rtapi_bitops\&.h> (for other atomic memory operations supported by rtapi)
